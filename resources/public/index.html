<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>File Upload — async + link history</title>
  <style>
    :root{--bg:#0b1220;--fg:#e9eef5;--acc:#3b82f6;--mut:#96a0b5}
    *{box-sizing:border-box}
    body{margin:0;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--fg);min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;width:min(1300px,100%)}
    .panel{background:#0f172a;border:1px solid #223;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.3);padding:18px;min-height:360px}
    h1{margin:0 0 8px;font-size:20px}
    p{margin:0 0 12px;color:var(--mut)}
    .drop{border:2px dashed #334155;border-radius:14px;padding:24px;text-align:center;transition:.15s;user-select:none}
    .drop.highlight{border-color:var(--acc);background:rgba(59,130,246,.08)}
    .btns{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    button,.ghost{padding:10px 14px;border-radius:10px;border:0;background:var(--acc);color:#fff;cursor:pointer}
    .ghost{background:#1f2937;color:var(--fg)}
    ul{list-style:none;padding:0;margin:12px 0 0;max-height:180px;overflow:auto;border-top:1px solid #223}
    li{display:flex;justify-content:space-between;gap:8px;padding:8px 0;border-bottom:1px dashed #223}
    small{color:var(--mut)}
    .row{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:10px}
    progress{width:100%;height:10px}
    .history{border:2px dashed #334155;border-radius:14px;padding:12px;min-height:360px}
    .history ol{margin:8px 0 0;padding-left:15px;max-height:420px;overflow:auto}
    .history li{display:grid;grid-template-columns:10fr 1fr 1fr 1fr;gap:8px;align-items:start}
    .history li a{word-break:break-word;text-decoration:none}
    .history li a:hover{text-decoration:underline}
  </style>
</head>
<body>
  <div class="grid">
    <section class="panel" aria-label="File upload">
      <h1>File Upload (async)</h1>
      <p>Drag and drop files or select manually. Upload via <code>fetch</code>. The server returns a link to the HTML.</p>

      <input id="fileInput" type="file" name="files" multiple hidden>

      <div id="drop" class="drop" tabindex="0" role="button" aria-label="Drop area for files">
        Drag files here or click
        <div class="btns">
          <button type="button" id="pick" class="ghost">Choose files</button>
          <button type="button" id="send">Send files</button>
        </div>
      </div>

      <ul id="list" aria-live="polite"></ul>
      <div class="row"><progress id="prog" max="100" value="0" hidden></progress><span id="status" aria-live="polite"></span></div>
    </section>

    <section class="panel" aria-label="Link history">
      <h1>Preview on the right → list of links</h1>
      <p>Saved in <code>localStorage</code>. Opens in a new tab.</p>
      <div class="history">
        <div class="row" style="justify-content:space-between;margin:0 0 6px 0">
          <strong>History</strong>
          <button type="button" id="clear" class="ghost">Clear</button>
        </div>
        <ol id="history"></ol>
      </div>
    </section>
  </div>

<script>
(() => {
  'use strict';
  // 1) Settings. Set your real endpoint here:
  const UPLOAD_URL = '/api/heatmap';
  // 2) Keys in localStorage:
  const LS_KEY = 'htmlLinksHistory';

  // 3) DOM elements:
  const drop = document.getElementById('drop');
  const fileInput = document.getElementById('fileInput');
  const pick = document.getElementById('pick');
  const sendBtn = document.getElementById('send');
  const list = document.getElementById('list');
  const prog = document.getElementById('prog');
  const status = document.getElementById('status');
  const historyEl = document.getElementById('history');
  const clearBtn = document.getElementById('clear');

  // === Link history on the right ===
  function loadHistory(){
    try{ return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }catch{ return []; }
  }
  function saveHistory(arr){ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }
  function addToHistory(link){
    const arr = loadHistory();
    if(!arr.includes(link)) arr.unshift(link);
    saveHistory(arr);
    renderHistory();
  }
  function clearHistory(){ saveHistory([]); renderHistory(); }
  function renderHistory(){
    const arr = loadHistory();
    historyEl.innerHTML = '';
    if(arr.length === 0){
      const li = document.createElement('li');
      li.textContent = 'No links yet';
      historyEl.append(li);
      return;
    }
    arr.forEach(link => {
      const li = document.createElement('li');

      const a0 = document.createElement('a');
      a0.href = '/api/heatmap/' + link;
      a0.target = '_blank'; a0.rel = 'noopener'; a0.textContent = "all";
      const a1 = document.createElement('a');
      a1.href = '/api/heatmap/' + link+"-cpu";
      a1.target = '_blank'; a1.rel = 'noopener'; a1.textContent = "cpu";
      const a2 = document.createElement('a');
      a2.href = '/api/heatmap/' + link+"-alloc";
      a2.target = '_blank'; a2.rel = 'noopener'; a2.textContent = "alloc";
      li.append(link, a0, a1, a2);
      historyEl.append(li);
    });
  }

  // === File handling on the left ===
  let batchSeq = 0;            // counter for selected file batches
  let lastSelectedBatchId = 0; // id of the last selected batch (what we send)

  // Render: add items to the list (DO NOT clear the list)
  function appendToList(files, batchId){
    const stamp = new Date().toLocaleTimeString();
    [...files].forEach(f => {
      const li = document.createElement('li');
      li.dataset.batch = String(batchId);
      li.title = `Batch #${batchId} · ${stamp}`;
      const name = document.createElement('span');
      const size = document.createElement('small');
      name.textContent = f.name;
      size.textContent = (f.size/1024).toFixed(1) + ' KB';
      li.append(name, size);
      list.append(li);
    });
  }

  // Set CURRENT files (overwrite input), visually — ADD to the end of the list
  function setFiles(files){
    const dt = new DataTransfer();
    [...files].forEach(f => dt.items.add(f));
    fileInput.files = dt.files; // only current batch in input
    lastSelectedBatchId = ++batchSeq;
    appendToList(files, lastSelectedBatchId);
  }

  // Delayed removal of a specific batch after 10 seconds
  function scheduleBatchClear(batchId, delayMs = 10000){
    setTimeout(() => {
      [...list.querySelectorAll(`li[data-batch="${batchId}"]`)].forEach(el => el.remove());
    }, delayMs);
  }

  // Full reset of input and progress (DO NOT clear the list — it will disappear by timer)
  function softResetAfterSend(){
    // clear input
    const dt = new DataTransfer();
    fileInput.files = dt.files;
    // leave progress and status: status will show "Done", hide progress
    prog.value = 0; prog.hidden = true;
  }

  // Send files via fetch (async)
  async function sendFiles(){
    if(!fileInput.files.length){ alert('Please select files first.'); return; }
    const currentBatch = lastSelectedBatchId; // remember what exactly we send
    try{
      status.textContent = 'Uploading…';
      prog.hidden = false;
      let fake = 0; const t = setInterval(()=>{fake=Math.min(99, fake+3); prog.value=fake;}, 120);

      const fd = new FormData();
      [...fileInput.files].forEach(f => fd.append('files', f, f.name));

      const resp = await fetch(UPLOAD_URL, {method:'POST', body: fd});
      clearInterval(t); prog.value = 100;
      if(!resp.ok) throw new Error('HTTP '+resp.status);

      const link = await resp.text().catch(()=>({}));
      if(!link){
        status.textContent = 'Uploaded, but the server did not return a link (expected html_url/link/url/href).';
      } else {
        status.textContent = 'Done';
        addToHistory(link);
      }

      // Do not remove current items immediately — only after 10 seconds
      scheduleBatchClear(currentBatch, 10000);
      softResetAfterSend();
    } catch(err){
      status.textContent = 'Error: ' + err.message;
      prog.hidden = true;
    }
  }

  // DnD events
  ['dragenter','dragover'].forEach(ev =>
    drop.addEventListener(ev, e => { e.preventDefault(); e.dataTransfer.dropEffect='copy'; drop.classList.add('highlight'); })
  );
  ['dragleave','drop'].forEach(ev =>
    drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.remove('highlight'); if(ev==='drop'){ setFiles(e.dataTransfer.files); }})
  );

  // Clicks and changes
  // drop.addEventListener('click', () => fileInput.click());
  pick.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', () => setFiles(fileInput.files));
  sendBtn.addEventListener('click', sendFiles);
  clearBtn.addEventListener('click', clearHistory);

  // Initialization
  renderHistory();
})();
</script>
</body>
</html>
